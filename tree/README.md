[TOC]



## 1、二叉树
「二叉树 binary tree」是一种非线性数据结构，代表着祖先与后代之间的派生关系，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。
```java
/* 二叉树节点类 */
class TreeNode {
    int val;         // 节点值
    TreeNode left;   // 左子节点引用
    TreeNode right;  // 右子节点引用
    TreeNode(int x) { val = x; }
}
```
每个节点都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，该节点被称为这两个子节点的「父节点 parent node」。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」。
<br>**在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。**

### 二叉树常见术语
* 「根节点 root node」：位于二叉树顶层的节点，没有父节点。
* 「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 null 。
* 「边 edge」：连接两个节点的线段，即节点引用（指针）。
* 节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。
* 节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。
* 二叉树的「高度 height」：从**根节点到最远叶节点**所经过的边的数量。
* 节点的「深度 depth」：从**根节点到该节点**所经过的边的数量。
* 节点的「高度 height」：从**距离该节点最远的叶节点到该节点**所经过的边的数量。
```text
    1
   / \
  2   3
 / \   \
4   5   6
二叉树的高度为 2
节点2的深度为 1
节点2的高度为 1
二叉树的深度 == 某节点的深度 + 该节点的高度
```

### 常见二叉树
1、完美二叉树<br>
「完美二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为h
，则节点总数为`2**h - 1`呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。
```text
    1
   / \
  2   3
 / \ / \
4  5 6  7
```
2、完全二叉树<br>
「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。
```text
    1
   / \
  2   3
 / \ /
4  5 6
```
3、完满二叉树<br>
「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点。
```text
    1
   / \
  2   3
     / \
    4   5
```
4、平衡二叉树<br>
「平衡二叉树 balanced binary tree」中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。
```text
    1
   / \
  2   3
 /   / \
4   5   6
   / \
  7   8
```

### 二叉树的退化
当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。

完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。
链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至
。
```text
    1                           1
   / \                         /
  2   3                       2
 / \ / \                     /
4  5 6  7                   3
完美二叉树                    退化链表
```


## 二叉树遍历
[Test](./src/Test.java)
* 层序遍历：通过队列先进先出
* 深度遍历
  * 前序遍历：根节点 -> 左子树 -> 右子树
  ```java
    public void preOrder(TreeNode root) {
        if (root == null) return;
        System.out.println(root.val);
        preOrder(root.left);
        preOrder(root.right);
    }
    ```
  * 中序遍历：左子树 -> 根节点 -> 右子树
  ```java
  public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        System.out.println(root.val);
        inOrder(root.right);
    }
    ```
  * 后序遍历：左子树 -> 右子树 -> 根节点
  ```java
    public void postOrder(TreeNode root) {
        if (root == null) return;
        postOrder(root.left);
        postOrder(root.right);
        System.out.println(root.val);
    }
    ```


## 数组形式的二叉树
根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：若节点的索引为 `i`
，则该节点的左子节点索引为 `2*i+1`
，右子节点索引为 `2*i+2`
**映射公式的角色相当于链表中的指针**。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点。
<br>
因为二叉树中层往往存在许多`null`，给定一个非完美二叉树，上述的数组表示方法已经失效。为了解决此问题，我们可以考虑在层序遍历序列中显式地写出所有
`null`。<br>
值得说明的是，完全二叉树非常适合使用数组来表示。回顾完全二叉树的定义，`null`
只出现在最底层且靠右的位置，因此所有`null`都
一定出现在层序遍历序列的末尾。

[ArrayBinaryTree](./src/ArrayBinaryTree.java)

二叉树数组形式主要有一下优点：
* 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。
* 不需要存储指针，比较节省空间。
* 允许随机访问节点。
<br>然而，数组表示也存在一些局限性。
* 数组存储需要连续内存空间，因此不适合存储数据量过大的树。
* 增删节点需要通过数组插入与删除操作实现，效率较低。
* 当二叉树中存在大量 `null` 时，数组中包含的节点数据比重较低，空间利用率较低。

## 二叉搜索树
「二叉搜索树 binary search tree」满足以下条件<br>
1. 对于根节点，左子树中所有节点的值 `<` 根节点的值 `<` 右子树中所有节点的值
2. 任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 
```text
                8
              /   \
             /     \
            /       \
           4        12
         /  \     /    \
        2    6   10    14
       / \  / \  / \   / \
      1  3  5 7 9  11 13 15
        
```
### 二叉搜索树的操作
[BinarySearchTree](./src/BinarySearchTree.java)

## AVL树

 

















